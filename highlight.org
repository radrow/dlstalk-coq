* Theorem

Things completely crucial to the point.


* Proposition

Important steps in proving Theorems, which mean something on their own. They should generally be mentioned in informal proofs.


* Lemma

- Intermediate steps in proving other things, with little value individually.
- Things that are easy to prove on paper, but annoying in Coq.
- If you would leave it as an "exercise for the reader", most likely it goes here.


* Corollary


Simplified or reduced versions of Theorems.


* Remark

Any "btw" steps which only a human would care for.


* Property

All "unpacking" lemmas, where there is a clear owner of the property. Proofs should be simple, ideally max induction+inversion.


* Fact

Things of zero value to the reader. All obvious, purely technical and Coq-quirky items should go here. For example rewrite lemmas.

* Sketch

** High-level pipeline:

1. Local transparency
2. Network transparency
3. Deadlock <=> cycle
4. SRPC sanity invariant
5. KIS & KIC invariants
6. Detect completeness & soundness

** Local transparency

*** Completeness

#+begin_src coq
  Transp_completeness
       : forall (path : list Mon.Proc.PAct) (S0 S1 : Mon.Proc.PQued)
           (MQ0 : MQ_clear) (M0 : Mon_ready),
         S0 =[ path ]=> S1 ->
         exists (mpath : list MAct) (M1 : Mon_ready),
           (instr MQ0 M0 S0 =[ mpath ]=>
            instr (exist _ nil (List.Forall_nil is_EvRecv))
              M1 S1) /\ mpath >:~ path
#+end_src

*** Soundness

#+begin_src coq
  Transp_soundness_base
       : forall (mpath0 : list MAct) (MS0 MS1 : MQued),
         MS0 =[ mpath0 ]=> MS1 -> MS0 =[ mpath0 ++ flush_path MS1 ]=> flush_MS MS1
#+end_src

** Net transparency

*** Completeness

#+BEGIN_SRC coq
  Net_Transp_completeness
       : forall (I0 : mon_assg) (N0 N1 : PNet),
         N0 =[ ?path ]=> N1 ->
         exists (mpath : list (Transp.Net.NAct (Act:=MAct))) (I1 : mon_assg),
           net_instr I0 N0 =[ mpath ]=> net_instr I1 N1
#+END_SRC

*** Soundness

#+BEGIN_SRC coq
  Net_Transp_soundness
       : net_instr ?I0 ?N0 =[ ?mnpath0 ]=> ?MN1 ->
         exists mnpath1 pnpath (I2 : mon_assg) (N2 : PNet),
           (?MN1 =[ mnpath1 ]=> net_instr I2 N2) /\ (?N0 =[ pnpath ]=> N2)
#+END_SRC


** Deadlock condition

Deadlocks are equivalent to dependency cycles extended by dependants

*** Completeness

#+begin_src coq

  deadset_dep_self
       : forall N : PNet,
         lock_uniq_type N ->
         lock_neq_nil_type N ->
         locks_dec_in N ->
         forall DS : Names, DeadSet DS N -> exists n : Name, List.In n DS /\ dep_on N n n

  deadlocked_dep_self
       : forall N : PNet,
         lock_uniq_type N ->
         lock_neq_nil_type N ->
         locks_dec_in N ->
         deadlocked n N -> exists n' : dep_on N n n' /\ dep_on N n' n'
#+end_src

*** Soundness

#+begin_src coq
  dep_self_deadset
       : forall N : PNet,
         lock_uniq_type N ->
         lock_neq_nil_type N ->
         forall n : Name, dep_on N n n -> exists DS : Names, List.In n DS /\ DeadSet DS N

  dep_self_deadlocked
       : forall N : PNet,
         lock_uniq_type N ->
         lock_neq_nil_type N ->
         forall n : Name, dep_on N n n -> deadlocked n N
#+end_src


** SRPC sanity

#+begin_src coq
    Definition SRPC_sane_Q_in (S : PQued) := forall c v v' I', Deq (c, Q) v (pq_I S) I' -> ~ List.In (c, Q, v') I'.
    Definition SRPC_sane_R_in (S : PQued) := forall s s' v v' I', Deq (s, R) v (pq_I S) I' -> ~ List.In (s', R, v') I'.
    Definition SRPC_sane_R_in_lock (S : PQued) := forall s v, List.In (s, R, v) (pq_I S) -> exists c, SRPC_pq (Lock c s) S.
    Definition SRPC_sane_Q_out_lock (S : PQued) := forall s v, List.In (s, Q, v) (pq_O S) -> exists c, SRPC_pq (Lock c s) S.
    Definition SRPC_sane_Q_out_last (S : PQued) := forall s v, ~ List.In (s, Q, v) (List.removelast (pq_O S)).
    Definition SRPC_sane_R_out_uniq (S : PQued) := forall c v v' O', Deq (c, R) v (pq_O S) O' -> ~ List.In (c, R, v') O'.
    Definition SRPC_sane_R_Q (S : PQued) := forall s v v', List.In (s, R, v) (pq_I S) -> ~ List.In (s, Q, v') (pq_O S).
    Definition SRPC_sane_Q_R (S : PQued) := forall s v v', List.In (s, Q, v) (pq_O S) -> ~ List.In (s, R, v') (pq_I S).
    Definition SRPC_sane_lock_Q (S : PQued) := forall c s, SRPC_pq (Lock c s) S -> pq_O S <> [] -> exists v, List.In (s, Q, v) (pq_O S).

    Definition SRPC_sane_in_Q_no_client (S : PQued) := forall c v, List.In (c, Q, v) (pq_I S) -> ~ proc_client c (pq_P S).
    Definition SRPC_sane_in_Q_no_out_R (S : PQued) := forall c v v', List.In (c, Q, v) (pq_I S) -> ~ List.In (c, R, v') (pq_O S).
    Definition SRPC_sane_client_no_out_R (S : PQued) := forall c v, proc_client c (pq_P S) -> ~ List.In (c, R, v) (pq_O S).
#+end_src

#+begin_src coq
  (* Every process is individually sane *)
  Definition SRPC_sane_net N := forall n, exists srpc, SRPC_sane srpc (NetMod.get n N).


  (* If n0 is locked on n1, then n1 handles the query of n0 *)
  Definition locks_sound N := forall n0 n1,
      net_lock_on N n0 n1 ->
      pq_client n0 (NetMod.get n1 N).


  (* If n1 handles a query from n0, then n0 is locked on n1   *)
  Definition locks_complete N := forall n0 n1,
      pq_client n0 (NetMod.get n1 N) -> net_lock_on N n0 n1.


  Inductive net_sane (N : PNet) : Prop :=
  | NetSane
      (H_Sane_SRPC : SRPC_sane_net N)
      (H_lock_sound : locks_sound N)
      (H_lock_complete : locks_complete N)
    : net_sane N.


  Theorem trans_invariant_net_sane : trans_invariant net_sane always.
#+end_src


** Detection

*** completeness

**** Variants & Invariants

#+begin_src coq
  (** Monitor is going to send a probe (inevitably) *)
  Inductive sends_probe : NChan -> MProbe -> MQued -> Prop :=
  | sp_init MQ MQ' c S n n' v p :
    NoRecvR_from n' MQ -> (* We won't unlock *)
    NoSends_MQ MQ -> (* We won't change the lock_id *)
    lock c = Some n' -> (* We are locked *)
    init p = self c -> index p = lock_id c -> (* Our hot probe *)
    sends_probe (n, R)
      p
      (mq
         (MQ ++ TrRecv (n, Q) v :: MQ') (* There is a query incoming... *)
         {|handle:=Rad.Rad_handle; state:=MRecv c|} (* We are ready to take it *)
         S
      )

  | sp_prop MQ MQ' c S n n' p :
    NoRecvR_from n' MQ -> (* We won't unlock *)
    NoSends_MQ MQ -> (* We won't change the lock_id *)
    lock c = Some n' -> (* We are locked *)
    init p <> self c -> (* The probe is not ours *)
    List.In n (waitees c) \/ (exists v, List.In (TrRecv (n, Q) v) MQ) -> (* The receiver will be in waitees *)
    sends_probe (n, R) p (mq (MQ ++ EvRecv (n', R) p :: MQ') {|handle:=Rad.Rad_handle; state:=MRecv c|} S)

  | sp_send MQ M h S nc p :
    sends_probe nc p (mq MQ {|handle:=h; state:=MSend nc p M|} S)

  | sp_late MQ M h S nc nc' p p' :
    (nc' <> nc \/ p' <> p) ->
    sends_probe nc p (mq MQ {|handle:=h; state:=M|} S) ->
    sends_probe nc p (mq MQ {|handle:=h; state:=MSend nc' p' M|} S)
  .


  Inductive KIC (MN : MNet) : Prop :=
  | KIC_
      (* We are sane *)
      (H_sane_C : net_sane '' MN)
      (* `self` is correct *)
      (H_self_C : forall n, _of self MN n = n)
      (* We are using the algorithm *)
      (H_Rad_C : forall n, handle (get_M MN n) = Rad.Rad_handle)
      (* Monitor knows about its lock. Note that if there was any R in MQ, it would not be locked. *)
      (H_lock_C : forall n0 n1, net_lock_on '' MN n0 n1 -> _of lock MN n0 = Some n1)
      (* Flushed monitor knows about everyone who waits on it *)
      (H_wait_C : forall n0 n1, net_lock_on '' MN n0 n1 -> NoRecvQ_from n0 (get_MQ MN n1) -> List.In n0 (_of waitees MN n1))
      (* Self-dependency implies alarm condition *)
      (H_alarm_C : forall n0, dep_on '' MN n0 n0 -> exists n1, dep_on '' MN n0 n1 /\ ac n1 MN)
      (* Dependency is decidable *)
      (H_dep_dec_C : forall n0 n1, dep_on '' MN n0 n1 \/ ~ dep_on '' MN n0 n1)
    : KIC MN.


  (** ** Alarm condition *)
  (** Either there is an alarm, or an alarm is inevitable due to probe and lock alignment *)
  Inductive ac (n : Name) (MN : MNet) : Prop :=
  | ac_alarm :
    _of alarm MN n = true ->
    ac n MN

  | ac_seek [m m'] :
    (n = m \/ dep_on '' MN n m) ->
    net_lock_on '' MN m m' ->  (* TODO: try to relate to mon states exlusively *)
    sends_probe (m, R) (hot_of MN n) (NetMod.get m' MN) ->
    ac n MN

  | ac_fin [n'] :
    net_lock_on '' MN n n' ->
    List.In (hot_ev_of MN n' n) (get_MQ MN n) ->
    ac n MN
  .


  detection_finito
     : forall (MN0 : MNet) (n : Name) (m : Que.Channel.Name),
       KIC MN0 ->
       deadlocked n '' MN0 ->
       net_lock_on '' MN0 n m ->
       List.In (hot_ev_of MN0 m n) (get_MQ MN0 n) ->
       exists (MN1 : MNet) (mpath : list (NAct (Act:=MAct))),
         (MN0 =[ mpath ]=> MN1) /\ _of Compl.alarm MN1 n = true.

  propagation_finito
     : forall (MN0 : MNet) (n m : Name) (m' : Que.Channel.Name) (p : MProbe),
       KIC MN0 ->
       dep_on '' MN0 n m ->
       net_lock_on '' MN0 m m' ->
       deadlocked m' '' MN0 ->
       hot MN0 p n ->
       sends_probe (m, Locks.R) p (NetMod.get m' MN0) ->
       exists (MN1 : MNet) (mpath : list (NAct (Act:=MAct))),
         (MN0 =[ mpath ]=> MN1) /\
         (exists n' : Srpc.Locks.Proc.Que.Channel.Name, _of Compl.alarm MN1 n' = true).


  Theorem ac_to_alarm [MN0 : MNet] [n] :
    KIC MN0 ->
    ac n MN0 ->
    dep_on '' MN0 n n ->
    exists MN1 mpath, (MN0 =[mpath]=> MN1) /\ (exists n', _of alarm MN1 n' = true).


  Theorem KIC_invariant : trans_invariant KIC always.
#+end_src


#+begin_src coq
  Theorem detection_completeness [N0] [I0] :
    KIC (net_instr I0 N0) ->
    Deadlocked N0 ->
    exists mpath MN1, (net_instr I0 N0 =[mpath]=> MN1) /\ exists n, _of alarm MN1 n = true.

  Corollary detection_completeness_uni [N0 N1] [ppath] [I0] :
    KIC (net_instr I0 N0) ->
    (N0 =[ ppath ]=> N1) ->
    Deadlocked N1 ->
    forall mpath0 I1,
      (net_instr I0 N0 =[ mpath0 ]=> net_instr I1 N1) ->
      exists mpath1 MN2,
        (net_instr I1 N1 =[ mpath1 ]=> MN2)
        /\ exists n, _of alarm MN2 n = true.

  Corollary detection_completeness_exi [N0 N1] [ppath] [I0] :
    KIC (net_instr I0 N0) ->
    (N0 =[ ppath ]=> N1) ->
    Deadlocked N1 ->
    exists mpath0 I1 mpath1 MN2,
      (net_instr I0 N0 =[ mpath0 ]=> net_instr I1 N1)
      /\ (net_instr I1 N1 =[ mpath1 ]=> MN2)
      /\ exists n, _of alarm MN2 n = true.
#+end_src

*** soundness

#+BEGIN_SRC coq
  Inductive sends_to_mon : MCode -> Name -> MProbe -> Prop :=
  | stm_find n p M : sends_to_mon (MSend (n, R) p M) n p
  | stm_seek n nc' p p' M :
    nc' <> (n, R) \/ p <> p' ->
    sends_to_mon M n p ->
    sends_to_mon (MSend nc' p' M) n p
  .

  #[export] Hint Constructors sends_to_mon : LTS.


  Definition sends_to N n0 n1 p := sends_to_mon (get_Mc N n0) n1 p.
  #[export] Hint Unfold sends_to : LTS_get.
  #[export] Hint Transparent sends_to : LTS.



  Inductive KIS (MN : MNet) :=
    KIS_
      (* We are sane *)
      (H_sane_S : net_sane '' MN)
      (* Dependency is decidable *)
      (H_dep_dec_C : forall n0 n1, dep_on '' MN n0 n1 \/ ~ dep_on '' MN n0 n1)
      (* `self` is correct *)
      (H_self_S : forall n0, _of self MN n0 = n0)
      (* We are using the algorithm *)
      (H_Rad_S : forall n0, handle (get_M MN n0) = Rad.Rad_handle)
      (* Monitor correctly judges the lock, unless there is a reply incoming it is about to see *)
      (H_lock_S : forall n0 n1, _of lock MN n0 = Some n1 -> net_lock_on '' MN n0 n1 \/ exists v, List.In (TrRecv (n1, R) v) (get_MQ MN n0))
      (* All members of the waiting list are locked on us *)
      (H_wait_S : forall n0 n1, List.In n0 (_of waitees MN n1) -> net_lock_on '' MN n0 n1)
      (* Monitors send probes only to those locked. *)
      (H_sendp_S : forall n0 n1 p, sends_to MN n1 n0 p -> net_lock_on '' MN n0 n1)
      (* All sent probes have their index no higher than the lock id of the initiator *)
      (H_index_send_S : forall n0 n1 p, sends_to MN n0 n1 p -> (index p <= _of lock_id MN (init p))%nat)
      (* All received probes have their index no higher than the lock id of the initiator *)
      (H_index_recvp_S : forall n0 n1 p, List.In (EvRecv (n1, R) p) (get_MQ MN n0) -> (index p <= _of lock_id MN (init p))%nat)
      (* If we are about to receive a hot probe of someone whose monitor considers locked, then we depend on them. *)
      (H_sendp_hot_S : forall n0 n1 n2, sends_to MN n1 n0 (hot_of MN n2) -> _of lock MN n2 <> None -> dep_on '' MN n0 n2)
      (* If we received a hot probe of someone whose monitor considers locked, then we depend on them. *)
      (H_recvp_hot_S : forall n0 n1 n2, List.In (hot_ev_of MN n2 n0) (get_MQ MN n1) -> _of lock MN n0 <> None -> dep_on '' MN n1 n0)
      (* No false alarms: if anyone screams, they are indeed deadlocked *)
      (H_alarm_S : forall n, _of alarm MN n = true -> dep_on '' MN n n)
      : KIS MN.


  detection_soundness
       : forall (I0 : mon_assg) (N0 : PNet) (MN1 : MNet) (mpath : list (NAct (Act:=MAct)))
           (n : Srpc.Locks.Proc.Que.Channel.Name),
         KIS (net_instr I0 N0) ->
         net_instr I0 N0 =[ mpath ]=> MN1 ->
         _of Compl.alarm MN1 n = true -> deadlocked n '' MN1
#+END_SRC
